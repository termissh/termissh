#!/usr/bin/env bash
set -euo pipefail

usage() {
    cat <<'EOF'
Usage:
  ./auto-release.sh "commit message"

Behavior:
  1) Stages all changes
  2) Creates a commit with your message
  3) Pushes current branch to origin
  4) Creates a new patch tag (vX.Y.Z)
  5) Pushes the tag
  6) Creates GitHub Release notes with commit list (if gh is available)

Notes:
  - Tag is auto-generated by incrementing the latest vX.Y.Z patch version.
  - If no previous tag exists, starts from v0.1.0.
EOF
}

if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then
    usage
    exit 0
fi

if ! command -v git >/dev/null 2>&1; then
    echo "[ERROR] git not found."
    exit 1
fi

if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    echo "[ERROR] Not inside a git repository."
    exit 1
fi

if [[ $# -ge 1 ]]; then
    COMMIT_MSG="$*"
else
    read -r -p "Commit mesaji: " COMMIT_MSG
fi

if [[ -z "${COMMIT_MSG// }" ]]; then
    echo "[ERROR] Commit message cannot be empty."
    exit 1
fi

BRANCH="$(git rev-parse --abbrev-ref HEAD)"
if [[ "$BRANCH" == "HEAD" ]]; then
    echo "[ERROR] Detached HEAD. Checkout a branch first."
    exit 1
fi

LATEST_TAG="$(git tag --list "v*" --sort=-v:refname | head -n1 || true)"
PREV_TAG=""
if [[ -n "$LATEST_TAG" ]]; then
    if [[ "$LATEST_TAG" =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
        MAJOR="${BASH_REMATCH[1]}"
        MINOR="${BASH_REMATCH[2]}"
        PATCH="${BASH_REMATCH[3]}"
        PATCH=$((PATCH + 1))
        NEW_TAG="v${MAJOR}.${MINOR}.${PATCH}"
        PREV_TAG="$LATEST_TAG"
    else
        echo "[ERROR] Latest tag is not SemVer (vX.Y.Z): $LATEST_TAG"
        exit 1
    fi
else
    NEW_TAG="v0.1.0"
fi

if git rev-parse -q --verify "refs/tags/$NEW_TAG" >/dev/null; then
    echo "[ERROR] Tag already exists locally: $NEW_TAG"
    exit 1
fi

if git ls-remote --exit-code --tags origin "refs/tags/$NEW_TAG" >/dev/null 2>&1; then
    echo "[ERROR] Tag already exists on origin: $NEW_TAG"
    exit 1
fi

echo "[INFO] Branch: $BRANCH"
echo "[INFO] Commit: $COMMIT_MSG"
echo "[INFO] New tag: $NEW_TAG"

git add -A

if git diff --cached --quiet; then
    echo "[ERROR] No changes to commit."
    exit 1
fi

git commit -m "$COMMIT_MSG"

echo "[INFO] Pushing branch..."
git push origin "$BRANCH"

git tag -a "$NEW_TAG" -m "Release $NEW_TAG - $COMMIT_MSG"
echo "[INFO] Created tag $NEW_TAG"

echo "[INFO] Pushing tag..."
git push origin "$NEW_TAG"

NOTES_FILE="$(mktemp)"
{
    echo "## Release Summary"
    echo "- Tag: $NEW_TAG"
    echo "- Branch: $BRANCH"
    echo "- Main commit: $COMMIT_MSG"
    echo
    echo "## Included Commits"
    if [[ -n "$PREV_TAG" ]]; then
        git log "${PREV_TAG}..HEAD" --pretty=format:"- %h %s (%an)"
    else
        git log --pretty=format:"- %h %s (%an)"
    fi
    echo
} >"$NOTES_FILE"

if command -v gh >/dev/null 2>&1 && gh auth status >/dev/null 2>&1; then
    if gh release view "$NEW_TAG" >/dev/null 2>&1; then
        gh release edit "$NEW_TAG" --notes-file "$NOTES_FILE" --title "$NEW_TAG"
        echo "[INFO] Updated existing GitHub release: $NEW_TAG"
    else
        gh release create "$NEW_TAG" --title "$NEW_TAG" --notes-file "$NOTES_FILE"
        echo "[INFO] Created GitHub release: $NEW_TAG"
    fi
else
    echo "[INFO] 'gh' not available or not authenticated."
    echo "[INFO] Tag push will trigger GitHub Actions release workflow."
fi

rm -f "$NOTES_FILE"

echo "[DONE] Commit, push, tag and release flow completed."
